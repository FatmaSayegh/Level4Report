% Implementation

\section{Front End Development with The Elm Programming Language}

The project is developed using the Functional Programming paradigm. This is a
paradigm which has been in development and practice since the days of infancy of
computer science. Functional programming is based on a form of computation
called lambda calculus proposed by Alonzo Church.

For most of the history of computing functional programming remained in the
ivory towers of universities for purposes of exploring theoretical computer
science and language research.

In the last decades however, programming languages such as Haskell and a few
dialects of LISP have escaped the ivory towers to find application in the
software industry.

In this section we will discuss, why functional programming was chosen as the
programming paradigm of choice. How the functional programming language called
Elm is used to write a well organized, maintainable, intuitive and
understandable code to produce a dynamic front end.

\subsection{Why Functional Programming?}
Functional programming, makes the programmer think in a different way than what
may be called imperative programming. In the functional paradigm, functions are
first class citizens, which can be mashed up together with each other, by
giving a function as input to another function, a function giving out another
function as an output, function composed of two functions dove-tailed to each
other, programming patterns being abstracted out as functions and so on.

For such Lego like usage of functions they must be dependable, such that for a
particular input a function will give a particular output just like
mathematical functions and has no business outside it's scope for side-effects.
With such confidence in the functions, they can be fitted with each other to
make them do complex computation.

\subsubsection{Separation of Concerns}
It may be asked that if functions don't have side effects, how do they print
output on the terminal or read file from the hard disk or accept inputs from a
user. Functional programming environments have a way of separating the pure
part of a program from the impure part, by introducing 'actions'. These
'actions' or side-effects are treated as a form of encapsulated data, which
can be manipulated by pure functions, and the environment makes changes to the
outside world by executing these actions.

Therefore the programmer has to himself a large part of the program where he
deals with just pure functions. This allows him to exploit the perfectness of
pure functional programming.

This separation of concerns of pure and impure code in the context of the Elm
programming language is discussed in the next section called the Elm
Architecture.

\subsection{The Elm Architecture}
The Elm Architecture is a pattern of writing Elm code for responsive web applications. 
The architecture separates the concerns of front-end development into the following categories:

\begin{enumerate}
\item Model
\item View
\item Update
\end{enumerate}

The Model is a data structure which holds the state of a program. This state is
used by the view function to render a webpage. The webpage, when rendered has
elements, which may trigger events, such as user inputs by the way of clicking
an HTML element. Such events are caught by the Elm runtime and sent to the update
function.  The update function takes these event messages and changes the
state. The changed state is then rendered by the view function to a modified
page.  Therefore, the Model is changed by the update function, whereas it is
used by the view function to render a webpage according to a formula set by the
programmer.

The events described above are called messages in the Elm way of naming things. For this particular
application they are defined as an Algebraic Data Type as:

\begin{lstlisting}[language=elm]
type Msg
    = TimeDelta Float
    | HoverOver Int
    | MouseOut Int
    | VertexClicked Int
    | AnimationToggle
    | AnimationStartOver
    | ToggleVertexStatus Int
    | NextTopic
    | PreviousTopic
    | MaxCutLine
    | ColoringSelectColor Color
    | VertexNonColor
    | NextAnimation 
    | PreviousTreeWidthAnimation
    | ToggleHelpStatus
    | Other
\end{lstlisting}
The messages are not just generated by user interaction with this application, they are 
are also generated by the animation clock as well as can be seen in the first data constructor of the type Msg.

\section{Implementation of Graphs}
Inside the program, a graph exists as data structure which contains a list of
vertices and a list of edges. The vertex which is a data type defined
separately consists of a name (which is an integer), a color, a 2D position (it
is actually implemented using a 3D vector, with z is always kept at zero).  An
edge on the other hand is defined as a combination of two vertices. Such Graphs
are present in the Model in and are used by the view function to be drawn as
SVG.

\subsection{Grid}
In the program a Grid is a list of 3D vectors, which can be taken in by certain
functions to make graphs or change shapes of graphs.  A list of Vertices,
therefore can be formed by zipping together lists of names, colors and a grid.
There are functions, especially for implementing animations, which takes two
grids and outputs a grid which is geometrically in between the two grids.

\subsection{Using Linear algebra to Initialize Grids}
Linear algebra, in particular manipulation of vectors using Matrices has been
used to create interesting grids for the placement of vertices in the scene.
This includes rotation, scaling and translation of vectors to from polygonal
patterns. Functions were created to form polygon with $n$ geometric vertices
which prove very handy in producing grids for various geometries like
the one seen in Graph Ismoporphism and Max k Cut examples.

As a small example, here is a functional programming code to find the centroid
of of three position vectors. You can observe how first two vectors are added
on line 1, and then it is pipelined to addition with a third vector, which is
in turn pipelined to being scaled by $0.33$ (divided by $3.0$). This could have
been achieved in a single line of code, but Elm reserves operators like $+$,
$-$, $*$ for only numbers and they can't be overloaded to work for vectors.

\begin{lstlisting}[language=elm]
Math.Vector3.add v1.pos v2.pos
|> Math.Vector3.add v3.pos
|> Math.Vector3.scale 0.333
\end{lstlisting}

\subsection{Implementing Colors}
To have a list of neighboring colors acting as a color palette we work on the Hue Saturation Lightness
color space (HSl), mostly varying the hue
just pass a
region in the spectrum of hues (First, Second or Third) and the number of
colors needed as an Integer. On a scale from $0.00$ to $1.00$, the first region will produce hues ranging from $0.00$ to $0.33$,
the second producing it from $0.33$ to $0.66$ and the third producing it between $0.66$ to $1.00$.


\subsection{Edges}
Edges are defined as a combination of two vertices. Since they are drawn as a
straight line segment between the positions of the two vertices, they do not require
positional data associated explicitly for them. It is drawn out from the vertices,
they contain.


\section{Implementation of Animations}
In this section, it will be explained how various animations in the
application are implemented. Though there are minor differences between animations
for one topic to another, they follow a common pattern. The common pattern is
this that events are generated by a quasi-regular clock. These events trigger
the update function which transforms the current state of the program and
changes the position of certain abstract entities. The view function while
redrawing these entities takes the position information from the updated model
to draw them as SVG (Scalable Vector Graphics).

\subsection{Morphing Geometry of a Graph}
In some of the animations in the application, the graph changes it's geometry to
visually look different than the original. This is accomplished by a function which takes a graph
and a grid and moves the graph incrementally towards the grid with every tick
of the animation clock.  The function calculates the displacement vector
between a vertex and the respective final position given in the grid and finds
a new position along the direction of the displacement vector.

\subsection{Re-formation of the Graphs}
At each tick of the animation clock the graph under transformation, is built
again, with vertices having the same name and color as the original but new
positions. The edges need to be re-constructed again as the vertex positions
have been renewed. This is something which is expected in the functional
programming paradigm where nothing is changed in place and new data structures
are created with application of a function. This is true not just for
animations, it is true for user-interaction or anything which requires visual
(Geometric or Color) modification of the graph.

