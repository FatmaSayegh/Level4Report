% Implementation
\graphicspath{ {images/} }

This chapter discusses the platform and the programming techniques employed to
implement the application.  This application is a web application meant to run
on browser. Traditionally, Javascript or programing languages which transpile
to Javascript are employed to execute such web apps. In the implementation of
this application a functional programming language called Elm which transpiles
to Javascript is used. Therefore, the chapter starts with explaining, the benefits
of using a functional programming in general and also how Elm uses Model, View, Update
architecture to implement a dynamic front end.

Furthermore, it will be discussed how the Graph as a data-structure is defined. How
it is drawn on screen as SVG (Scalable Vector Graphics). How a function
generates a color palette for the coloring of the vertices. How vertices are
laid out in various geometrical patterns and how animations are implemented
among other things.


\section{Front End Development with The Elm Programming Language}

The project is developed using the Functional Programming paradigm. This is a
paradigm which has been in development and practice since the days of infancy
of computer science. Functional programming is based on a form of computation
called lambda calculus proposed by Alonzo Church. See \cite{Hudak2007}.

For most of the history of computing functional programming remained in the
ivory towers of universities for purposes of exploring theoretical computer
science and language research.

In the last decades however, programming languages such as Haskell and a few
dialects of LISP have escaped the ivory towers to find application in the
software industry.

In this section we will discuss, why functional programming was chosen as the
programming paradigm of choice. How the functional programming language called
Elm is used to write a well organized, maintainable, intuitive and
understandable code to produce a dynamic front end.

\subsection{Why Functional Programming?}
Functional programming, makes the programmer think in a different way than what
may be called imperative programming. In the functional paradigm, functions are
first class citizens, which can be mashed up together in myriad different ways
such as the following -


\begin{enumerate}
\item A function given as input to a another function. 
\item A function producing another function as an output.
\item Composition of two functions dove-tailed to each other to produce another function.
\item Programming patterns being abstracted out as functions.
\end{enumerate}

For such Lego like usage of functions they must be dependable, such that for a
particular input a function will give a particular output just like
mathematical functions and has no business outside it's scope for side-effects.
With such confidence in the functions, they can be fitted with each other to
make them do complex computation. See \cite{Hughes89}.

Since the functional code is more reasonable and logical than imperative
programming the runtime errors are substantially less than imperative
programming and is easier to maintain.


\subsubsection{Separation of Concerns}
It may be asked that if functions don't have side effects, how do they print
output on the terminal or read file from the hard disk or accept inputs from a
user. Functional programming environments have a way of separating the pure
part of a program from the impure part, by introducing `actions'. These
`actions' or side-effects are treated as a form of encapsulated data, which
can be manipulated by pure functions, and the environment makes changes to the
outside world by executing these actions.

Therefore the programmer has to himself a large part of the program where he
deals with just pure functions. This allows him to exploit the perfectness of
pure functional programming.

This separation of concerns of pure and impure code in the context of the Elm
programming language is discussed in the \autoref{elm: architecture} called \emph{the Elm
Architecture}.

\subsection{Why Elm Programming Language for This Project?}

For the reasons in the previous sections, a functional programming language was chosen
keeping in mind that the size of this project would be quite substantial.
Unlike JavaScript, Elm does not require any external framework such as Angular
or React. This makes the program easier to reason with and maintainable.

Although, Elm is a new language which may not have as much community support as
JavaScript and it's various frameworks have, it has a compiler which gives
friendly error messages almost guiding the programmer for correct usage of the
language.

\subsection{The Elm Architecture}
\label{elm: architecture}
The Elm Architecture is a pattern of writing Elm code for responsive web applications. 
The architecture separates the concerns of front-end development into the following categories:

\begin{enumerate}
\item Model
\item View
\item Update
\end{enumerate}

The Model is a data structure which holds the state of a program. See
\cite{Fairbank19}. This state is used by the view function to render a webpage.
The webpage, when rendered has elements, which may trigger events, such as user
inputs by the way of clicking an HTML element. Such events are caught by the
Elm runtime and sent to the update function.  The update function takes these
event messages and changes the state. The changed state is then rendered by the
view function to a modified page.  Therefore, the Model is changed by the
update function, whereas it is used by the view function to render a webpage
according to a formula set by the programmer.

\section{Events as Messages}
The events described in section \autoref{elm: architecture} generated by
animation clocks and clicks of the user on graph elements and buttons, are
called messages in the Elm way of naming things. For this particular
application they are defined as an Algebraic Data Type as:

\begin{lstlisting}[language=elm, caption={Abstract Data Type Msg with it's Data Constructors.}]
type Msg
    = TimeDelta Float                  -- Clock Ticks for Animation
    | HoverOver Int                    -- Event when Mouse over a Vertex                              
    | MouseOut Int                     -- Event when Mouse out from a Vertex                               
    | VertexClicked Int                -- Event when Vertex Clicked                              
    | AnimationToggle                  -- Pause or Play Animation
    | AnimationStartOver               -- Restart Animation
    | ToggleVertexStatus Int           -- Select/Unselect Animation
    | NextTopic                        -- Next Topic
    | PreviousTopic                    -- Previous Topic
\end{lstlisting}
The messages are not just generated by user interaction with this application,
they are are also generated by the animation clock as well as can be seen in
the first data constructor of the type $Msg$.
The clock ticks and the key strokes are events which initiate the update function to act on Model.
The animation clock and key presses need to be subscribed from the Elm runtime in the following way:

\begin{lstlisting}[language=elm, caption={Subscriptition of Animation clock and Key presses services}]
subscription : Model -> Sub Msg
subscription _ =
    Sub.batch
        [ E.onAnimationFrameDelta TimeDelta
        , E.onKeyPress keyDecoder
        ]
\end{lstlisting}

\section{Implementation of Graphs}
Inside the program, a graph exists as data structure which contains a list of
vertices and a list of edges. The vertex, as can be seen in \autoref{code: typeGraph} which is a data type defined
separately consists of a name (which is an integer), a color, a 2D position (it
is actually implemented using a 3D vector, with z is always kept at zero).  An
edge on the other hand is defined as a combination of two vertices. Such Graphs
are present in the Model in and are used by the view function to be drawn as
SVG.

\begin{lstlisting}[  language=elm, 
                     caption={
                              Definition of Vertex, Edge and Graph.  Vertex is
                              defined as a data structure which has a name as
                              an integer, a position as a 3 dimensional vector,
                              color, and a flag which depicts if it has been
                              selected by the user.  An Edge has two Vertices and
                              a Graph contains a list of Vertices and a list of
                              Edges.
                             }
                  ,  label={code: typeGraph}
                  ]

-- Definition of Vertex
type alias Vertex =
    { name : Int, pos : Vec3, color : Color, glow : Bool }

-- Definition of Edge
type alias Edge =
    { vertexOne : Vertex, vertexTwo : Vertex }

-- Definition of Graph
type alias Graph =
    { vertices : List Vertex, edges : List Edge }
\end{lstlisting}

\subsection{Grid}
In the program a Grid is a list of 3D vectors or in other words a list of
position for vertices, which can be taken as an input by certain functions to
construct graphs or change shapes of graphs. 

A list of Vertices, for example can be formed by combining together lists of
names, colors and a grid.

Grids are important in implementing animations. There is a function, for
example, which which take two grids and output a grid which is geometrically in
between the two grids.

\subsection{Using Linear algebra to Initialize Grids}
Linear algebra, in particular manipulation of vectors using Matrices has been
used to create interesting grids for the placement of vertices in the scene.
This includes rotation, scaling and translation of vectors to from polygonal
patterns. Functions were created to form polygon with $n$ geometric vertices
which prove very handy in producing grids for various geometries like
the one seen in Graph Ismoporphism and Max k Cut examples.

As a small example, here is a functional programming code in \autoref{code:
centroid} to find the centroid of of three position vectors. You can observe
how first two vectors are added on line 3, and then it is pipelined to addition
with a third vector, which is in turn pipelined to being scaled by $0.33$
(divided by $3.0$). This could have been achieved in a single line of code, but
Elm reserves operators like $+$, $-$, $*$ for only numbers and they can't be
overloaded to work for vectors.

\begin{lstlisting}[  language=elm
                  ,  caption={Finding Centroid of Three Vertices.}
                  ,  label={code: centroid}
                  ]
findCentroidOfVertices : Vertex -> Vertex -> Vertex -> Vec3
findCentroidOfVertices v1 v2 v3 =
   Math.Vector3.add v1.pos v2.pos
   |> Math.Vector3.add v3.pos
   |> Math.Vector3.scale 0.333
\end{lstlisting}

\subsection{Implementing Colors}
To have a list of neighboring colors acting as a color palette we work on the
Hue Saturation Lightness color space (HSl), mostly varying the hue just pass a
region in the spectrum of hues (First, Second or Third) and the number of
colors needed as an Integer. On a scale from $0.00$ to $1.00$, the first region
will produce hues ranging from $0.00$ to $0.33$, the second producing it from
$0.33$ to $0.66$ and the third producing it between $0.66$ to $1.00$.

\subsection{Edges}
Edges are defined as a combination of two vertices. Since they are drawn as a
straight line segment between the positions of the two vertices, they do not require
positional data associated explicitly for them. It is drawn out from the vertices,
they contain.

\begin{figure}[h]
\centering
\includegraphics[scale=0.05]{Graph1New}
\caption{Implementation of a Graph}
\end{figure}

\section{Implementation of Animations}
In this section, it will be explained how various animations in the
application are implemented. Though there are minor differences between animations
for one topic to another, they follow a common pattern. The common pattern is
this that events are generated by a quasi-regular clock. These events trigger
the update function which transforms the current state of the program and
changes the position of certain abstract entities. The view function while
redrawing these entities takes the position information from the updated model
to draw them as SVG.

\subsection{Morphing Geometry of a Graph}
In some of the animations in the application, the graph changes it's geometry
to visually look different than the original. This is accomplished by a
function which takes a graph and a grid to move the input graph incrementally
towards the grid with every tick of the animation clock. The function
calculates the displacement vector between a vertex and the respective final
position given in the grid and finds a new position along the direction of the
displacement vector.

\subsection{Re-formation of the Graphs}
At each tick of the animation clock the graph under transformation, is built
again, with vertices having the same name and color as the original but new
positions. The edges need to be re-constructed again as the vertex positions
have been renewed. This is something which is expected in the functional
programming paradigm where nothing is changed in place and new data structures
are created with application of a function. This is true not just for
animations, it is true for user-interaction or anything which requires visual
(Geometric or Color) modification of the graph.

The re-formation of the vertices and the edges are quite explicitly shown in
the Elm function shown in \autoref{code: morphGraph}. The function takes a
graph and a grid and produces a new graph situated at the new grid with new
vertices and edges.  The edges formed in the new graph are connected to the
same vertices (vertices with the same names, actually) as the original ones.

\begin{lstlisting}[language=elm, 
      caption={
      Changing the shape of a graph for animation.
      The first line, in the code describes the Type Signature of the function
      morphGraph. It says that the function takes a Graph and a Grid as input
      and produces a Graph as an output.
      The input Graph's vertices adopt the positions listed in the Grid.
   }
   , label={code: morphGraph}
   ]
morphGraph : Graph -> Grid -> Graph
morphGraph graph grid =
    let
        updatedVertices =
            List.map2 updatePositionVertex graph.vertices grid

        createEdge =
            updateEdge updatedVertices

        updatedEdges =
            List.map createEdge graph.edges
    in
    Graph updatedVertices updatedEdges

\end{lstlisting}

\subsection{Drawing of Graphs}
Drawing graphs is done using SVG elements. The vertices are drawn as color
filled circles while the edges are drawn as straight line segments between the
positions of the related vertices. The edges are drawn first and the vertices
later so that vertices appear on top of the edges and the edges seem to be
appearing out of the surface of the vertices.

\section{Explanation Panel}
The Explanation Panel consist of the title of the topic and suggestions on how
to interpret and interact with the animations and user interactions. This panel
is populated with text and buttons by functions which take the state (Model) of
the program as input. According to the state of the program appropriate
advises, instructions and buttons are spawned on the panel.

The functions responsible for Explanation Panel in the case of user interaction
such as the ones in Graph Coloring and minimum vertex cover run a check on the
state of the program to know if the user is doing his task correctly. For
example in graph coloring, if two adjacent vertices are colored the same color,
there appears a message in the explanation panel warning about the same.

\section{Navigation and Control}
There are several buttons and keyboard shortcuts to go from one topic to the
next and to play/pause and restart animations. These have been implemented by
generating appropriate messages which are caught by the update function which
in turn updates the model (state of the program). The updated model of the
program is reflected on the screen by the view function.

\subsection{Navigation Bar}
The navigation bar consists of buttons to go to the previous and the next
topics.  When the message $PreviousTopic$ or the message $NextTopic$ is
generated by the buttons respectively, the update function catches it to change
the state of the program (a data structure known as Model) to load it with the
details of the previous/next topic.

\subsection{Keyboard Shortcuts}
Keyboard shortcuts provide a fast way to test various functionalities while
developing the application.  These functionalities have not been taken away
even after development therefore they still can be used to trigger events in
the application. 
The key presses messages are registered by the elm run-time which in turn
triggers the update function to update the model. The updated model is now
rendered by the view function. Information about the keyboard shortcuts can be
availed on the screen by pressing the information icon present in the
navigation bar. Below is an example list of a few key-bindings.

\begin{itemize}
\item \textbf{p}: Toggle between pause and play animation. (Can be used instead of the Play/Pause button; Generates the $AnimationToggle$ message). \\
\item \textbf{r}: Restart animation. (Can be used instead of Restart Button; Generates the $AnimationStartOver$ message). \\
\item \textbf{n}: Go to the next topic. (Can be used instead of the navigation button; Generates the $NextTopic$ message). \\
\item \textbf{N}: Go to the previous topic. (Can be used instead of the navigation button; Generates the $PreviousTopic$ message). \\
\item \textbf{t}: Next animation (Can be used in case of Max k Cut and Tree width to go to the next animation; Generates the $NextAnimation$ message)
\end{itemize}

\section{Software Engineering Practices}
In the following subsections, how a few good practices which were adopted to
make the project of this size manageable and organized are explained.

\subsection{Version Control}
The program along with the documentation and the dissertation report were
version controlled in a single GitHub repository. A git repository, gives the
developer confidence for fearless refactoring and feature enhancement by the
way of creating separate branches for separate issues. Therefore a different
branch was created for editing documentation, and it was made sure that
modification in code files was not done on this branch. Similarly, a branch for
code refactoring didn't modify the documentation part hence separating
concerns.  Furthermore a branch was conveniently discarded if an adventure in a
radical change in code went wrong.

\subsection{Continuous Deployment}
The web application concerning the project is deployed on the World Wide Web
using Netlify. It is a service which lets one host a front end website. It is
connected to the master branch of the GitHub repository of the project. Every
time a new version is pushed to the master, netlify service fetches the new
version of the app from the repository, builds it according to the build script
present in the GitHub repository and deploys the web application on a specific
URL. The build and deployment can also be done manually by going to the
dashboard of the Netlify website. The build and deployment process primarily
consists of running a script to transpile Elm code to a JavaScript file and copy
the output along with the boiler plate HTML to the publish directory.

\subsection{Documentation}
Documentation for the project was done in a continuous fashion in a variety of
ways, such as a wiki for code implementation and a guide for future work, time
logging for project management and report writing for the submission. 

The wiki was informed heavily from the code comments made to explain the
functions. Time logging brought a sense of discipline in the whole endeavor.
It also helped in estimating time required to complete the tasks which lay in
future and asses the learning curve.
