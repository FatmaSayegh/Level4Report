% Implementation

This chapter discusses the platform and the programming techniques employed to
implement the application.  This application is a web application meant to run
on browser. Traditionally, Javascript or programing languages which transpile
to Javascript are employed to execute such web apps. In the implementation of
this application a functional programming language called Elm which transpiles
to Javascript is used. Therefore, the chapter starts with explaining, the benefits
of using a functional programming in general and also how Elm uses Model, View, Update
architecture to implement a dynamic front end.

Furthermore, it will be discussed how the Graph as a data-structure is defined. How
it is drawn on screen as SVG (Scalable Vector Graphics). How a function
generates a color palette for the coloring of the vertices. How vertices are
laid out in various geometrical patterns and how animations are implemented
among other things.


\section{Front End Development with The Elm Programming Language}

The project is developed using the Functional Programming paradigm. This is a
paradigm which has been in development and practice since the days of infancy of
computer science. Functional programming is based on a form of computation
called lambda calculus proposed by Alonzo Church.

For most of the history of computing functional programming remained in the
ivory towers of universities for purposes of exploring theoretical computer
science and language research.

In the last decades however, programming languages such as Haskell and a few
dialects of LISP have escaped the ivory towers to find application in the
software industry.

In this section we will discuss, why functional programming was chosen as the
programming paradigm of choice. How the functional programming language called
Elm is used to write a well organized, maintainable, intuitive and
understandable code to produce a dynamic front end.

\subsection{Why Functional Programming?}
Functional programming, makes the programmer think in a different way than what
may be called imperative programming. In the functional paradigm, functions are
first class citizens, which can be mashed up together with each other, by
giving a function as input to another function, a function giving out another
function as an output, function composed of two functions dove-tailed to each
other, programming patterns being abstracted out as functions and so on.

For such Lego like usage of functions they must be dependable, such that for a
particular input a function will give a particular output just like
mathematical functions and has no business outside it's scope for side-effects.
With such confidence in the functions, they can be fitted with each other to
make them do complex computation.

\subsubsection{Separation of Concerns}
It may be asked that if functions don't have side effects, how do they print
output on the terminal or read file from the hard disk or accept inputs from a
user. Functional programming environments have a way of separating the pure
part of a program from the impure part, by introducing 'actions'. These
'actions' or side-effects are treated as a form of encapsulated data, which
can be manipulated by pure functions, and the environment makes changes to the
outside world by executing these actions.

Therefore the programmer has to himself a large part of the program where he
deals with just pure functions. This allows him to exploit the perfectness of
pure functional programming.

This separation of concerns of pure and impure code in the context of the Elm
programming language is discussed in the next section called the Elm
Architecture.

\subsection{The Elm Architecture}
The Elm Architecture is a pattern of writing Elm code for responsive web applications. 
The architecture separates the concerns of front-end development into the following categories:

\begin{enumerate}
\item Model
\item View
\item Update
\end{enumerate}

The Model is a data structure which holds the state of a program. This state is
used by the view function to render a webpage. The webpage, when rendered has
elements, which may trigger events, such as user inputs by the way of clicking
an HTML element. Such events are caught by the Elm runtime and sent to the update
function.  The update function takes these event messages and changes the
state. The changed state is then rendered by the view function to a modified
page.  Therefore, the Model is changed by the update function, whereas it is
used by the view function to render a webpage according to a formula set by the
programmer.

The events described above are called messages in the Elm way of naming things. For this particular
application they are defined as an Algebraic Data Type as:
\begin{lstlisting}[language=elm]
type Msg
    = TimeDelta Float                  -- Clock Ticks for Animation
    | HoverOver Int                    -- Event when Mouse over a Vertex                              
    | MouseOut Int                     -- Event when Mouse out from a Vertex                               
    | VertexClicked Int                -- Event when Vertex Clicked                              
    | AnimationToggle                  -- Pause or Play Animation
    | AnimationStartOver               -- Restart Animation
    | ToggleVertexStatus Int           -- Select/Unselect Animation
    | NextTopic                        -- Next Topic
    | PreviousTopic                    -- Previous Topic
\end{lstlisting}
The messages are not just generated by user interaction with this application,
they are are also generated by the animation clock as well as can be seen in
the first data constructor of the type $Msg$.
The clock ticks and the key strokes are events which initiate the update function to act on Model.
The animation clock and key presses need to be subscribed from the Elm runtime in the following way:
\begin{lstlisting}[language=elm]
subscription : Model -> Sub Msg
subscription _ =
    Sub.batch
        [ E.onAnimationFrameDelta TimeDelta
        , E.onKeyPress keyDecoder
        ]
\end{lstlisting}

\section{Implementation of Graphs}
Inside the program, a graph exists as data structure which contains a list of
vertices and a list of edges. The vertex which is a data type defined
separately consists of a name (which is an integer), a color, a 2D position (it
is actually implemented using a 3D vector, with z is always kept at zero).  An
edge on the other hand is defined as a combination of two vertices. Such Graphs
are present in the Model in and are used by the view function to be drawn as
SVG.

\subsection{Grid}
In the program a Grid is a list of 3D vectors, which can be taken in by certain
functions to make graphs or change shapes of graphs.  A list of Vertices,
therefore can be formed by zipping together lists of names, colors and a grid.
There are functions, especially for implementing animations, which takes two
grids and outputs a grid which is geometrically in between the two grids.

\subsection{Using Linear algebra to Initialize Grids}
Linear algebra, in particular manipulation of vectors using Matrices has been
used to create interesting grids for the placement of vertices in the scene.
This includes rotation, scaling and translation of vectors to from polygonal
patterns. Functions were created to form polygon with $n$ geometric vertices
which prove very handy in producing grids for various geometries like
the one seen in Graph Ismoporphism and Max k Cut examples.

As a small example, here is a functional programming code to find the centroid
of of three position vectors. You can observe how first two vectors are added
on line 1, and then it is pipelined to addition with a third vector, which is
in turn pipelined to being scaled by $0.33$ (divided by $3.0$). This could have
been achieved in a single line of code, but Elm reserves operators like $+$,
$-$, $*$ for only numbers and they can't be overloaded to work for vectors.

\begin{lstlisting}[language=elm]
Math.Vector3.add v1.pos v2.pos
|> Math.Vector3.add v3.pos
|> Math.Vector3.scale 0.333
\end{lstlisting}

\subsection{Implementing Colors}
To have a list of neighboring colors acting as a color palette we work on the
Hue Saturation Lightness color space (HSl), mostly varying the hue just pass a
region in the spectrum of hues (First, Second or Third) and the number of
colors needed as an Integer. On a scale from $0.00$ to $1.00$, the first region
will produce hues ranging from $0.00$ to $0.33$, the second producing it from
$0.33$ to $0.66$ and the third producing it between $0.66$ to $1.00$.

\subsection{Edges}
Edges are defined as a combination of two vertices. Since they are drawn as a
straight line segment between the positions of the two vertices, they do not require
positional data associated explicitly for them. It is drawn out from the vertices,
they contain.


\section{Implementation of Animations}
In this section, it will be explained how various animations in the
application are implemented. Though there are minor differences between animations
for one topic to another, they follow a common pattern. The common pattern is
this that events are generated by a quasi-regular clock. These events trigger
the update function which transforms the current state of the program and
changes the position of certain abstract entities. The view function while
redrawing these entities takes the position information from the updated model
to draw them as SVG.

\subsection{Morphing Geometry of a Graph}
In some of the animations in the application, the graph changes it's geometry
to visually look different than the original. This is accomplished by a
function which takes a graph and a grid to move the input graph incrementally
towards the grid with every tick of the animation clock. The function
calculates the displacement vector between a vertex and the respective final
position given in the grid and finds a new position along the direction of the
displacement vector.

\subsection{Re-formation of the Graphs}
At each tick of the animation clock the graph under transformation, is built
again, with vertices having the same name and color as the original but new
positions. The edges need to be re-constructed again as the vertex positions
have been renewed. This is something which is expected in the functional
programming paradigm where nothing is changed in place and new data structures
are created with application of a function. This is true not just for
animations, it is true for user-interaction or anything which requires visual
(Geometric or Color) modification of the graph.

The re-formation of the vertices and the edges are quite explicitly shown in
the Elm function below. The function takes a graph and a grid and produces a
new graph situated at the new grid with new vertices and edges.  The edges
formed in the new graph are connected to the same vertices (vertices with the
same names, actually) as the original ones.

\begin{lstlisting}[language=elm]
morphGraph : Graph -> Grid -> Graph
morphGraph graph grid =
    let
        updatedVertices =
            List.map2 updatePositionVertex graph.vertices grid

        createEdge =
            updateEdge updatedVertices

        updatedEdges =
            List.map createEdge graph.edges
    in
    Graph updatedVertices updatedEdges
\end{lstlisting}

\subsection{Drawing of Graphs}
Drawing graphs is done using SVG elements. The vertices are drawn as color
filled circles while the edges are drawn as straight line segments between the
positions of the related vertices. The edges are drawn first and the vertices
later so that vertices appear on top of the edges and the edges seem to be
appearing out of the surface of the vertices.

\section{Explanation Panel}
The Explanation Panel consist of the title of the topic and suggestions on how
to interpret and interact with the animations and user interactions. This panel
is populated with text and buttons by functions which take the state (Model) of
the program as input. According to the state of the program appropriate
advises, instructions and buttons are spawned on the panel.

The functions responsible for Explanation Panel in the case of user interaction
such as the ones in Graph Coloring and minimum vertex cover run a check on the
state of the program to know if the user is doing his task correctly. For
example in graph coloring, if two adjacent vertices are colored the same color,
there appears a message in the explanation panel warning about the same.

\section{Implementation of Miscellaneous features}
There are a few miscellaneous features which must be mentioned here.
\subsection{Navigation Bar}
The navigation bar consists of buttons to go to the previous and the next
topics.  When the message $PreviousTopic$ or the message $NextTopic$ is
generated by the buttons, the update function catches it to change the state of
the program (a data structure known as Model) to load it with the details of
the previous/next topic.

\subsection{Keyboard Shortcuts}
Keyboard shortcuts provide a fast way to test various functionalities while
developing the application.  These functionalities have not been taken away
even after development therefore they still can be used to trigger events in
the application. 
The key presses are noted by the elm run-time which in turn triggers the update function
to update the model. The updated model is now rendered by the view function.
Below is an example list of a few key-bindings.
\begin{itemize}
\item p: Toggle between pause and play animation. (Can be used instead of the Play/Pause button).
\item r: Restart animation. (Can be used instead of Restart Button).
\item n: Go to the next topic. (Can be used instead of the navigation button).
\item N: Go to the previous topic. (Can be used instead of the navigation button).
\item t: Next animation (Can be used in case of Max k Cut and Tree width to go to the next animation)
\end{itemize}

\section{Software Engineering Practices}
In the following subsections, how a few good practices which were adopted to
make the project of this size managable and organized are explained.

\subsection{Version Control}
The program along with the documentation and the dissertation report were
version controlled in a single GitHub repositiory. A git repository, gives the
developer confidence for fearless refactoring and feature enhancement by the
way of creating seperate branches for seperate issues.

\subsection{Continous Deployment}
The web application is deployed using Netlify. It is a service which lets one
host a front end website.  It is connected to the master branch of the GitHub
repository of the poject. Every time a new version is pushed to the master,
netlify service fetches the new version of the app from the repository, builds
it according to the build script present in the GitHub repository and deploys
the web application.

\subsection{Documentation}

