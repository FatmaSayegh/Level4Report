%Background

This chapter introduces concepts which are essential to understand the
later chapters in this report. First, I review relevant books and research papers referred and consulted for this project, then discuss Graph Theory definitions and its classical
problems, which are useful to understand their implementation in the application.
Discussion of prior work on visualization of computer science topics which have
an influence over this project is also part of the research.

\section{Literature Review}
The books and the research papers cited in this project range
from theoretical texts on Graph Theory, to programming books on functional
programming and the web front end functional programming language called
Elm.

\subsection{Graph Theory and Algorithms Literature}
Parts of the following literature was used to gain some basic familiarity with the
basics of graph theory and understanding of definitions, theorems and 
explanations of classical graph theory problems. This literature
also played a role in shortlisting the graph theory problems which  
will be implemented as examples in the developed application.

\subsubsection{Networks: An Introduction.}
\cite{Newman10} was consulted for definitions, explanations and understanding of
basics of Graph Theory and its problems. It discusses the mathematical and
computer science perspectives of the subject in dedicated sections.

\subsubsection{Algorithm Design.}
\autoref{explanation: treewidth} lent the description and the example of \emph{Tree-width} problem
incorporated for an animation in the application. \cite{KleinbergTardos06} covers most kinds of data structures and has excellent portion on mathematical and
computer science aspect of Graph theory.

\subsection{Functional Programming and The Elm Programming Literature}
In this section, literature covering functional programming and in particular
Elm programming language which were helpful in this project is reviewed.

\subsubsection{Why Functional Programming Matters.}
\cite{Hughes89} is a concise tutorial using a Haskell like programming language called
Miranda, presenting the power of functional and modular thinking to glue
functions together to create and manipulate data structures like lists and
trees. It also discusses recurring patterns in programming and their
abstraction in form of higher order functions such as maps, filters, and folds. In a steep learning curve it goes onto discuss some advanced concepts
in Artificial Intelligence.

\subsubsection{Elm in Action.}
\cite{feldman2020elm} may be used as a step by step tutorial introduction to the Elm
language and its use in creating real world web applications. It starts with
small applications and gradually moves to the management projects of
considerable size. It acts as a bridge between functional programming and
front-end design; it also covers into front-end design recipes; for example how
to implement a single page application.

\subsection{User Interface Aesthetics and Usability}
\subsubsection{The Beauty of Simplicity.}
{Karvonen2000} presents arguments for how optimal simplicity, minimalism and
intuitiveness make a user interface more usable and trustworthy. This paper inspired me strongly to keep the application simple by minimising the number of complicated
control and features.

\section{Discussion of Classical Graph Theory Problems}
This section formally discusses the concepts of Graph theory which are
elucidated visually in the application.  I will be referring to the subsections here for definitions and explanations and I recommend reading this section carefully for readers not yet familiar with this topic.

\subsection{Definitions}
\label{graphtheory: definitions}
A \emph{Graph} $\boldsymbol{G}$, can be understood as a collection of vertices which are
connected to each other by edges.  A \emph{Vertex} $\boldsymbol{v}$ can be understood as a
point and an \emph{Edge} $\boldsymbol{e}$ is a pair of vertices.  The \emph{set of all the vertices}
in a graph $G$ is represented as $\boldsymbol{V(G)}$ and the \emph{set of all the
edges} in $G$ is represented as $\boldsymbol{E(G)}$.

For a vertex $v$, its \emph{degree} $\boldsymbol{deg(v)}$ is the number of edges
connected to it.  An \emph{isolated vertex} $v$ is such that $deg(v) = 0$. An
\emph{end vertex} is a vertex $w$ such that $deg(w) = 1$.  Two vertices are
\emph{adjacent} to each other if there is an edge connects them.

A \emph{bipartite} graph is a graph $G$ such that its vertices $V(G)$ can
be split into two disjoint sets $A$ and $B$ such that each edge of $G$ joins a
vertex of $A$ and a vertex of $B$. \cite{Newman10} 


\subsection{Graph Isomporphism}
Two graphs $G_1$ and $G_2$ are isomorphic if there is a one to one correspondence
between the vertices of $G_1$ and $G_2$ such that the number of edges between any
two vertices in $G_1$ is equal to the number of edges joining the corresponding
vertices of $G_2$.  Given two graphs, detecting if the graphs are Isomorphic is
a problem to solve as the graphs may appear to be different in appearance and
in the labeling of the nodes and edges. \cite{Newman10}

\subsubsection{Application}
The graph isomorphism problem finds application in the field of bioinformatics
for finding network motifs (sub-graphs isomorphic to an input pattern) in a
larger biological network. A network motif is a recurring pattern of connection
of vertices in a large graph signifying their evolutionary selection over
random patterns. \cite{Bonnici2013}

\subsection{Max K Cut}
A maximum cut is partioning the vertices of a graph in two groups such that
the number of edges between these two groups is maximum. In a weighted graph,
where the edges are weighted, the weights of the edges are also taken into
consideration.  A maximum k-cut is generalized version of maximum cut, where
the graph is partitioned into k subsets, such that the number of edges between
these groups is maximized.

It is important to note that a bipartite graph (refer to the Definitions
section above) is a trivial example of Max Cut there are no edges among the
vertices of a set $A$ and no edges among the vertices of set B and all the edges
are from the vertices in set $A$ to vertices in set $B$.

\subsection{Graph Colouring}
Graph Colouring is optimization problem where the objective is to assign to the vertices
of a graph a colour such that no two adjacent vertices have the same colour,
while keeping the number of colours employed to a minimum. Here a colour can be
thought of just any symbol from a finite set of symbols.

\subsection{Minimum Vertex Cover}
Minimum Vertex Cover of a graph is the minimum amount of vertices such that,
all the edges in the graph must have one of such vertices as at least one of
their endpoints. This is also a optimization problem in which the constraint is
that all the edges must be covered while keeping the number of vertices in the
set of Minimum Vertex Cover to the minimum.

\subsection{Tree Width}
\label{explanation: treewidth}
This topic will be discussed in two parts. First a tree decomposition of a
graph is described, then the tree width of a graph will be defined.

To decompose a Graph in a tree is to put nodes into sets called pieces, subject
to certain conditions.  The first condition is that all the vertices of $G$
should belong to at least one piece. Every edge of $G$, must be present in
at least one piece which contains both ends of the edge.  And finally, in the
tree decomposition, if there is a node $n$ present in a walk from a node $n_1$
to $n_2$, and if both $n_1$ and $n_2$ have a vertex $v$ in common, then the node
$n$ also contains that vertex $v$. 

Any graph can be decomposed into a tree. Trivially, a graph can be tree
decomposed by putting all of its vertices in just one node. But it will not be
a very useful tree decomposition.  Therefore a good tree decomposition of a
tree is the one which has small pieces.  Tree width is defined as the size of
the biggest piece $V_t - 1$. A tree-width of a graph is the minimum of such
possible tree widths across all possible tree-decompositions. \cite{KleinbergTardos06}

\section{Prior Work}
This project takes subtle inspirations from some of the work which is available
on the internet as web applications for visualization of popular algorithms.
Although the works which are discussed in this section are focused on
understanding algorithmic solutions of computer science problems, the
visualization of graphs, trees and lists in these projects have been inspiring
for depiction of graphs and their animation in this project.

\subsection{Data Structure Visualizations}
\label{priorWork: datastrucvisu}
This tool was developed by David Galles, Associate Professor at University of San
Francisco. \cite{Galles} covers topics
from various categories of computer science problems such as Dynamic
Programming, Geometric Programming, Trees, Heaps and Graphs.

The design of the tool has several important features: The user has the
facility to define their own data-structures rather than they being predefined or
hard-coded. There are control buttons which allow the user to start pause and
restart the animations. There is a slider to tune the speed of the animation as
well.

I find this tool lacking in textual explanation of the algorithms while they run and I assume that the main purpose of this tool is as a classroom teaching aid such that the
teacher first explains the topic and uses the tool as a visual demonstration to
show his students the working of the algorithm on real data structures.

\subsection{VisuAlgo}
\label{priorWork: visualgo}
VisuAlgo was developed by Dr. Steven Halim of National University of
Singapore. \cite{HalimVisu} covers topics from the
subject of data structures and algorithms. Most relevant for this project are
the topics related to graph theory; which are Maximum Flow, Minimum Vertex
Cover, Traveling Salesman and Steiner Tree, although the emphasis is on
algorithmic solutions to the problems and not problem visualization which is
the emphasis of this project.

For most topics the user is able to construct their instances of datastructures.
Unlike Data Structure Visualization application mentioned in
\autoref{priorWork: datastrucvisu}, there is an ample amount of textual
information in terms of theory, tutorial and instructions. The explanation of
the topics is done in text blocks which appear at appropriate places in a slide
show like fashion. For organizing the textual information, it has drop down
content menu for easy access to various sections. Although, different positions
of the text blocks can be a little distracting. In this project, the text explanation
is shown in one place.


\subsection{Algmatch}
\label{priorWork: algmatch}
\emph{Algmatch} was developed as a final year individual project dissertation for
by Liam Lau under the supervision of Sofiat Olaosebikan, supervisor of this project as well. The application
visualizes the matching algorithms such as Gale-Shapley Stable Matching and
Extended Gale-Shapley Stable Matching algorithms applied to stable marriage and
hospital/residents problem. \cite{LiamApp}
lends ideas about user friendliness and intuitive usage.

It has a panel which describes the algorithm steps while in an animation the
matching algorithm works on an instance of the problem.

Aesthetically, the most noteworthy features of the app are, playback and speed
controls which are as intuitive as media buttons on a media player and smooth
page transitions resulting in fluid user interactions.
