% Conclusion

\section{Reflections}

%\subsection{On Learning Impact}
%\subsection{On Problem Explanation}
%\subsection{}

\subsection{Experience on Project Management}
For a project of this size, well begun is half done. The majority of the work
must be completed should be done early. The concluding days of the project
should be reserved for evaluation, and feedback and subsequent changes.

The project, in retrospection was done in the several phases. The
\emph{first} phase which lasted a week was about how to spawn a page on a
Single Page Application and how to use vectors and matrices to position
elements of Scalable Vector Graphics. The \emph{second} phase was how to
implement graph, vertices and edge data-structures; achieving translation and
morphing animations and development of the graph isomorphism topic and making
it's explanation panel. The \emph{third} phase, which took almost a month was
to use the learning from the topic to implement rest of the topics and
refactoring the code in several modules.


Functional programming paradigm contributed in preserving sanity for managing
the size of the program. More reflection on this is in \autoref{reflection:
functional}. 

\subsection{Experience on the Evaluation of the Application}
It was observed that while gathering opinion and advice on usage of an
application, specially a kind which has a particular utility in terms of
education and learning; quality of advice is better than it's quantity. The most
valuable advice and opinions came from the research scholars and postgraduates
in the field of computer science who had either conducted research in the field
or had taken a semester course on it. Such advice was adopted and appropriate
changes were subsequently made.


\subsection{Experience of using Functional programming for Front End Programming} 
\label{reflection: functional}

Here is a reflection on the experience of using functional programming for this
project. This experience will also be compared to past experience in
programming in imperative languages.

A web app today is one of the primary means of human computer interaction
(HCI). To model something as complex as a HCI a programming paradigm which can
model this complexity efficiently is needed. 

An imperative programming language, however \emph{high-level} it might be, is
much closer to the Von-Nueman machine in terms of how a computer program is
reasoned about by the programmer. There is a tape and it has to be read one
step at a time. The programmer implements most of the logic in terms of control
mechanisms and less in terms of logic itself. Therefore the program becomes far
more complex than the actual complexity it has to represent. 

Functional programming on the other hand was much more efficient in modelling
the domain to be represented. It implemented logic more in terms of logic and
less in terms of control structures. Such that while reading the program one
mostly saw logic and not boiler-plate code.

Using Elm in representing the world inside the application and the signals
which are received from the outside was simple and elegant. The functional
\emph{type system} gave a structure for organizing, extending and refactoring
the project which continued to grow in size and complexity. The ease of
extending the application nudged the development style towards more of a
bottom-up style. Functionality of the animations were coded before pages, and
pages were done before the whole of the app.

While types made modelling the domain efficient. Functions made the rules of
physics in the web application explicit. Pattern matching on the inputs of the
functions was used extensively in the code to take logical decisions. Another
important method was pipeling the output of a function to the input of another
function. Reading a series of pipelined functions, was easy to reason with as
it seemed like data is being processed on an assembly line with functions
acting on it in turn.
