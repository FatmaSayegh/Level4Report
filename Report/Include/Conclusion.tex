% Conclusion

\section{Reflections}

%\subsection{On Learning Impact}
%\subsection{On Problem Explanation}
%\subsection{}

\subsection{Experience of using Functional programming for Front End Programming} 

Here is a reflection on the experience of using functional programming for this
project. This experience will also be compared to past experience in
programming in imperative languages.

A web app today is one of the primary means of human computer interaction
(HCI). To model something as complex as a HCI a programming paradigm which can
model this complexity efficiently is needed. 

An imperative programming language, however \emph{high-level} it might be, is
much closer to the Von-Nueman machine in terms of how a computer program is
reasoned about by the programmer. There is a tape and it has to be read one
step at a time. The programmer implements most of the logic in terms of control
mechanisms and less in terms of logic itself. Therefore the program becomes far
more complex than the actual complexity it has to represent. 

Functional programming on the other hand was much more efficient in modelling
the domain to be represented. It implemented logic more in terms of logic and
less in terms of control structures. Such that while reading the program one
mostly saw logic and not boiler-plate code.

Using Elm in representing the world inside the application and the signals
which are received from the outside was simple and elegant. The functional
\emph{type system} gave a structure for organizing, extending and refactoring
the project which continued to grow in size and complexity. The ease of
extending the application nudged the development style towards more of a
bottom-up style. Functionality of the animations were coded before pages, and
pages were done before the whole of the app.

While types made modelling the domain efficient. Functions made the rules of
physics in the web application explicit. Pattern matching on the inputs of the
functions was used extensively in the code to take logical decisions. Another
important method was pipeling the output of a function to the input of another
function. Reading a series of pipelined functions, was easy to reason with as
it seemed like data is being processed on an assembly line with functions
acting on it in turn.
